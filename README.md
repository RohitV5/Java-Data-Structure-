
primitive type - flota int double boolean

non primitive types - string, array (which has some functions and created using new keyword).

casting - implicit (automatic), explicit (manual) using cast()

defining const with final keyword.

operators: arithmetic, logic, comparison

Math class - some useful functions like min, max , random

strings are immutable - once defined u can' change its value in memory.

How to Approach a DSA problem


Checklist:

Sorting algorithms
-quicksort
-mergesort
-heapsort

Search algorithms
-binary search
-linear search

Data structures for efficient searching and retrieval
-hash tables
-binary search trees.


Graph algorithms
-Dijkstra's shortest path algorithm
-Breadth-First Search (BFS) algorithm.

Dynamic programming algorithms
-Longest Common Subsequence (LCS) algorithm
-the Knapsack problem.

Greedy algorithms
-Huffman coding
-Activity Selection problem.

Divide and Conquer algorithms
-merge sort
-Quick sort

Backtracking algorithms
-n-Queens problem
-Sudoku solver



Steps to solve DSA

1.Understand the problem: Read the problem statement carefully and make sure you understand what is being asked. Break down the problem into smaller, more manageable sub-problems if necessary.
2.Identify teh inputs and outputs. Determing what inputs the problem require and what output are expected.
3.Consider the constraints. Take note of any constraints or limitations that may affect how you approach the problem.
4.Explore different solutions. Think about different ways to solve the problem, and consider the trade-offs between them.
5.Choose a solution. Select the approach that you believe will work best and start implementing it in code.
6.Optimize the solution. Look for ways to improve the performance of your solution.
7.Test your solution. Test your solution with a sample inputs and edge cases to ensure it works correctly. 
8.Refactor the solution. If necessary, consider refactoring the solution to improve readability maintainability and performance.
9.Analyze the space and time complexity. It is important to measure how well the solution performs in terms of time and space complexity.

It is difficult to provide a definitive ranking of all data structures and algorithms based on difficulty, as the level of difficulty can vary depending on a person's background and experience. However, some common data structures and algorithms that are considered to be relatively easy to understand and implement include:

Arrays
Linked Lists
Stacks
Queues
Trees (Binary Trees, AVL Trees, etc.)
Hash Tables
Sorting algorithms (Bubble Sort, Selection Sort, Insertion Sort, etc.)
Searching algorithms (Linear Search, Binary Search, etc.)
As the complexity increases, below are the dsa are considered to be more difficult to understand and implement:

Graphs (Graph Traversal, Shortest Path, etc.)
Dynamic Programming (Fibonacci sequence, Longest Common Subsequence, etc.)gch
Greedy Algorithms
Divide and Conquer (Merge Sort, Quick Sort, etc.)
Backtracking (N-Queens, Sudoku Solver, etc.)
Heaps (Heap Sort, Priority Queue, etc.)
Tries (Prefix Trees)
Advanced algorithms like Bellman-Ford, Dijkstra, A*, Prim Algorithm
Please note that this is just a rough guide and the actual difficulty level may vary depending on the individual.






https://www.youtube.com/watch?v=Dr4PpNa7AYo&list=PLfqMhTWNBTe3LtFWcvwpqTkUSlB32kJop&index=6
